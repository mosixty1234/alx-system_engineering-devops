Web Infrastructure Design
Definitions and Explanations
1. **Reason for Adding Additional Elements**: When we introduce a new server, we achieve two important goals. Firstly, it allows us to implement a load balancer, which efficiently handles high volumes of incoming traffic. Secondly, this setup helps us eliminate the vulnerability of a single point of failure that arises when relying on a single server.
2. **Load Balancer Distribution Algorithm**: Our load balancer operates using the Round Robin algorithm. This algorithm connects to servers in a sequential order, distributing requests evenly. Each server serves requests in turn. Once all servers have received a request, the cycle begins anew. This algorithm is suitable for servers of equal specifications and when persistent connections are not numerous.
3. **Active-Active vs. Active-Passive Setup**: Our load balancer employs an Active-Active setup. In this configuration, both nodes (servers) provide the same service concurrently. In contrast, an Active-Passive setup has only one node active while others remain inactive. For instance, in a two-node setup, if the first node is active, the second is in standby. The key distinction lies in performance. Active-Active clusters utilize all server resources during normal operation, whereas active-passive setups only activate the backup server during failover.
4. **Database Primary-Replica (Master-Slave) Cluster**: The master-slave replication mechanism involves copying data from a master database server to one or more slave database servers. Updates made on the master are logged and then replicated to the slaves. Synchronous replication occurs when changes are simultaneously made on both master and slave, while asynchronous replication involves queued changes written later. This setup is commonly used to distribute read access across multiple servers for scalability. It also serves purposes like failover and data analysis on the slave to prevent overloading the master.
5. **Primary Node vs. Replica Node**: The replica node functions as a duplicate of the primary node. It serves two key roles: safeguarding against hardware failures by offering redundant copies of the application codebase, and enhancing capacity to handle read requests, such as searches or document retrieval.
